{"version":3,"file":"index.umd.js","sources":["../index.js"],"sourcesContent":["const KEYCODE = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n}\n\nconst state = new Map()\n\nexport const rovingIndex = ({element:rover, target:selector}) => {\n  // this api allows empty or a query string\n  const target_query = selector || ':scope *'\n  const targets = rover.querySelectorAll(target_query)\n  const startingPoint = targets[0]\n\n  // take container out of the focus flow\n  rover.tabIndex = -1\n  // and all the children\n  targets.forEach(a => a.tabIndex = -1)\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  })\n    \n  // when container or children get focus\n  rover.addEventListener('focusin', _ => {\n    if (state.get('last_rover') == rover) return\n\n    activate(rover, state.get(rover).active)\n    state.set('last_rover', rover)\n  })\n\n  // watch for arrow keys\n  rover.addEventListener('keydown', e => {\n    switch (e.keyCode) {\n      case KEYCODE.RIGHT:\n      case KEYCODE.DOWN:\n        e.preventDefault()\n        focusNextItem(rover)\n        break\n      case KEYCODE.LEFT:\n      case KEYCODE.UP:\n        e.preventDefault()\n        focusPreviousItem(rover)\n        break\n    }\n  })\n}\n\nconst focusNextItem = rover => {\n  const rx = state.get(rover)\n\n  // increment state index\n  rx.index += 1\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1)\n    rx.index = rx.targets.length - 1\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index]\n\n  // found something, activate it\n  next && activate(rover, next)\n}\n\nconst focusPreviousItem = rover => {\n  const rx = state.get(rover)\n\n  // decrement from the state index\n  rx.index -= 1\n\n  // clamp to 0 and above only\n  if (rx.index < 1)\n    rx.index = 0\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index]\n\n  // found something, activate it\n  prev && activate(rover, prev)\n}\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover)\n\n  // remove old tab index item\n  rx.active.tabIndex = -1\n\n  // set new active item and focus it\n  rx.active = item\n  rx.active.tabIndex = 0\n  rx.active.focus()\n}"],"names":["state","Map","activate","rover","item","rx","get","active","tabIndex","focus","element","targets","querySelectorAll","target","startingPoint","forEach","a","set","index","addEventListener","_","e","keyCode","preventDefault","length","next","focusNextItem","prev","focusPreviousItem"],"mappings":"kOAAA,IAOMA,EAAQ,IAAIC,IAkFZC,EAAW,SAACC,EAAOC,GACvB,IAAMC,EAAKL,EAAMM,IAAIH,GAGrBE,EAAGE,OAAOC,UAAY,EAGtBH,EAAGE,OAASH,EACZC,EAAGE,OAAOC,SAAW,EACrBH,EAAGE,OAAOE,uBAzFe,gBAAUN,IAARO,QAGrBC,EAAUR,EAAMS,mBAHoBC,QAET,YAE3BC,EAAgBH,EAAQ,GAG9BR,EAAMK,UAAY,EAElBG,EAAQI,QAAQ,SAAAC,UAAKA,EAAER,UAAY,IAEnCM,EAAcN,SAAW,EAIzBR,EAAMiB,IAAId,EAAO,CACfQ,QAAAA,EACAJ,OAAQO,EACRI,MAAO,IAITf,EAAMgB,iBAAiB,UAAW,SAAAC,GAC5BpB,EAAMM,IAAI,eAAiBH,IAE/BD,EAASC,EAAOH,EAAMM,IAAIH,GAAOI,QACjCP,EAAMiB,IAAI,aAAcd,MAI1BA,EAAMgB,iBAAiB,UAAW,SAAAE,GAChC,OAAQA,EAAEC,SACR,KAtCG,GAuCH,KAtCE,GAuCAD,EAAEE,iBAYY,SAAApB,GACpB,IAAME,EAAKL,EAAMM,IAAIH,GAGrBE,EAAGa,OAAS,EAGRb,EAAGa,MAAQb,EAAGM,QAAQa,OAAS,IACjCnB,EAAGa,MAAQb,EAAGM,QAAQa,OAAS,GAGjC,IAAIC,EAAOpB,EAAGM,QAAQN,EAAGa,OAGzBO,GAAQvB,EAASC,EAAOsB,GAzBlBC,CAAcvB,GACd,MACF,KA7CE,GA8CF,KA7CA,GA8CEkB,EAAEE,iBAwBgB,SAAApB,GACxB,IAAME,EAAKL,EAAMM,IAAIH,GAGrBE,EAAGa,OAAS,EAGRb,EAAGa,MAAQ,IACbb,EAAGa,MAAQ,GAGb,IAAIS,EAAOtB,EAAGM,QAAQN,EAAGa,OAGzBS,GAAQzB,EAASC,EAAOwB,GArClBC,CAAkBzB"}