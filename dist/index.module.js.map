{"version":3,"file":"index.module.js","sources":["../index.js"],"sourcesContent":["const KEYCODE = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n}\n\nconst state = new Map()\n\nexport const rovingIndex = ({element:rover, target:selector}) => {\n  // this api allows empty or a query string\n  const target_query = selector || ':scope *'\n  const targets = rover.querySelectorAll(target_query)\n  const startingPoint = targets[0]\n\n  // take container out of the focus flow\n  rover.tabIndex = -1\n  // and all the children\n  targets.forEach(a => a.tabIndex = -1)\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  })\n    \n  // when container or children get focus\n  rover.addEventListener('focusin', _ => {\n    if (state.get('last_rover') == rover) return\n\n    activate(rover, state.get(rover).active)\n    state.set('last_rover', rover)\n  })\n\n  // watch for arrow keys\n  rover.addEventListener('keydown', e => {\n    switch (e.keyCode) {\n      case KEYCODE.RIGHT:\n      case KEYCODE.DOWN:\n        e.preventDefault()\n        focusNextItem(rover)\n        break\n      case KEYCODE.LEFT:\n      case KEYCODE.UP:\n        e.preventDefault()\n        focusPreviousItem(rover)\n        break\n    }\n  })\n}\n\nconst focusNextItem = rover => {\n  const rx = state.get(rover)\n\n  // increment state index\n  rx.index += 1\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1)\n    rx.index = rx.targets.length - 1\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index]\n\n  // found something, activate it\n  next && activate(rover, next)\n}\n\nconst focusPreviousItem = rover => {\n  const rx = state.get(rover)\n\n  // decrement from the state index\n  rx.index -= 1\n\n  // clamp to 0 and above only\n  if (rx.index < 1)\n    rx.index = 0\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index]\n\n  // found something, activate it\n  prev && activate(rover, prev)\n}\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover)\n\n  // remove old tab index item\n  rx.active.tabIndex = -1\n\n  // set new active item and focus it\n  rx.active = item\n  rx.active.tabIndex = 0\n  rx.active.focus()\n}"],"names":["state","Map","rovingIndex","rover","element","targets","querySelectorAll","target","startingPoint","tabIndex","forEach","a","set","active","index","addEventListener","_","get","activate","e","keyCode","preventDefault","focusNextItem","focusPreviousItem","rx","length","next","prev","item","focus"],"mappings":"AAAA,IAOMA,EAAQ,IAAIC,IAELC,EAAc,gBAAUC,IAARC,QAGrBC,EAAUF,EAAMG,mBAHoBC,QAET,YAE3BC,EAAgBH,EAAQ,GAG9BF,EAAMM,UAAY,EAElBJ,EAAQK,QAAQ,SAAAC,UAAKA,EAAEF,UAAY,IAEnCD,EAAcC,SAAW,EAIzBT,EAAMY,IAAIT,EAAO,CACfE,QAAAA,EACAQ,OAAQL,EACRM,MAAO,IAITX,EAAMY,iBAAiB,UAAW,SAAAC,GAC5BhB,EAAMiB,IAAI,eAAiBd,IAE/Be,EAASf,EAAOH,EAAMiB,IAAId,GAAOU,QACjCb,EAAMY,IAAI,aAAcT,MAI1BA,EAAMY,iBAAiB,UAAW,SAAAI,GAChC,OAAQA,EAAEC,SACR,KAtCG,GAuCH,KAtCE,GAuCAD,EAAEE,iBACFC,EAAcnB,GACd,MACF,KA7CE,GA8CF,KA7CA,GA8CEgB,EAAEE,iBACFE,EAAkBpB,OAMpBmB,EAAgB,SAAAnB,GACpB,IAAMqB,EAAKxB,EAAMiB,IAAId,GAGrBqB,EAAGV,OAAS,EAGRU,EAAGV,MAAQU,EAAGnB,QAAQoB,OAAS,IACjCD,EAAGV,MAAQU,EAAGnB,QAAQoB,OAAS,GAGjC,IAAIC,EAAOF,EAAGnB,QAAQmB,EAAGV,OAGzBY,GAAQR,EAASf,EAAOuB,IAGpBH,EAAoB,SAAApB,GACxB,IAAMqB,EAAKxB,EAAMiB,IAAId,GAGrBqB,EAAGV,OAAS,EAGRU,EAAGV,MAAQ,IACbU,EAAGV,MAAQ,GAGb,IAAIa,EAAOH,EAAGnB,QAAQmB,EAAGV,OAGzBa,GAAQT,EAASf,EAAOwB,IAGpBT,EAAW,SAACf,EAAOyB,GACvB,IAAMJ,EAAKxB,EAAMiB,IAAId,GAGrBqB,EAAGX,OAAOJ,UAAY,EAGtBe,EAAGX,OAASe,EACZJ,EAAGX,OAAOJ,SAAW,EACrBe,EAAGX,OAAOgB"}